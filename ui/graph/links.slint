import { NodeData, LinkData } from "state.slint";

export global LinkLogic {
    callback new_link_from_output(int, int);
    callback attach_link_to_output(int, int);
    callback new_link_from_input(int, int);
    callback attach_link_to_input(int, int);
}


export global LinkLayout {
    pure public function colorFromstring(ty: string) -> color {
        if ty == "TXT" {
            #FA80C9
        } else if ty == "IMG"{
            #47FFDE
        } else {
            #A676F5
        }
    }

    pure public function srcX(src: NodeData) -> float {
        return (src.x + src.width - 23px) / 1px;
    }

    pure public function srcY(src: NodeData, src_slot: int) -> float {
        return (src.y + 10px + 5px + 4px + 5px + 16px) / 1px + 16 * src_slot;
    }

    pure public function dstX(dst: NodeData) -> float {
        return (dst.x + 12px) / 1px;
    }

    pure public function dstY(dst: NodeData, dst_slot: int) -> float {
        return (dst.y + 10px + 5px + 4px + 5px + 16px) / 1px + 16 * dst_slot;
    }
}

export component Link inherits Rectangle {
    in property <LinkData> link;
    in property <[NodeData]> nodes;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    Path {
        stroke: LinkLayout.colorFromstring(link.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo {
            x: (LinkLayout.srcX(nodes[link.src])+5+offset-x) * zoom;
            y: (LinkLayout.srcY(nodes[link.src], link.src_slot)+5 + offset-y) * zoom;
        }

        CubicTo { 
            control-1-x: (LinkLayout.srcX(nodes[link.src])+5 + 100 + offset-x) * zoom;
            control-1-y: (LinkLayout.srcY(nodes[link.src], link.src_slot)+5 + offset-y) * zoom; 

            control-2-x: (LinkLayout.dstX(nodes[link.dst])+5 - 100 + offset-x) * zoom;
            control-2-y: (LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5 + offset-y) * zoom; 

            x: (LinkLayout.dstX(nodes[link.dst])+5 + offset-x) * zoom;
            y: (LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5 + offset-y) * zoom; 
        }
    }
}

export component LinkSlots inherits Rectangle {
    in property <LinkData> link;
    in property <[NodeData]> nodes;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    Rectangle {
        x: ((LinkLayout.srcX(nodes[link.src]) + offset-x) * 1px) * zoom;
        y: (LinkLayout.srcY(nodes[link.src], link.src_slot) + offset-y) * 1px * zoom;
        width: 11px * zoom;
        height: 8px * zoom;

        VerticalLayout {
            alignment: LayoutAlignment.center;

            Image {
                source: @image-url("../../assets/right-chevron.svg");
                colorize: LinkLayout.colorFromstring(link.ty).brighter(0.3);
                width: 11px * zoom;
                height: 8px * zoom;
            }
        }
        
    }

    Rectangle {
        x: (LinkLayout.dstX(nodes[link.dst]) + offset-x) * 1px * zoom;
        y: (LinkLayout.dstY(nodes[link.dst], link.dst_slot) + offset-y) * 1px * zoom;
        width: 11px * zoom;
        height: 8px * zoom;

        VerticalLayout {
            alignment: LayoutAlignment.center;

            Image {
                source: @image-url("../../assets/left-chevron.svg");
                colorize: LinkLayout.colorFromstring(link.ty).brighter(0.3);
                width: 11px * zoom;
                height: 8px * zoom;
            }
        }
    }
}

