import { LinkData, NodeData, FloatingLinkData, FloatingState, FieldType } from "state.slint";
import { LinkLayout, LinkLogic } from "links.slint";
import { StandardListView, TextEdit, LineEdit } from "std-widgets.slint";

export global NodeLogic {
    callback move_node(int, length, length);
    callback set_field(int, string, string, string);
}

component IntInput inherits VerticalLayout {
    in property<string> text;
    in property<string> default-value;
    in property<InputType> input-type : InputType.number;

    callback edited(string);
    
    Text {
        text: parent.text;
    }

    LineEdit {
        width: 100%;
        height: 20px;
        font-size: 14px;
        input-type: parent.input-type;
        text: parent.default-value;

        edited(text) => {
            parent.edited(text);
        }
    }
}

export component Node inherits Rectangle {
    in-out property <NodeData> n;
    in property <int> node_idx;
    in-out property <[NodeData]> nodes;
    in property <FloatingLinkData> floating;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    x: (n.x + offset-x*1px) * zoom;
    y: (n.y - 10px + offset-y*1px) * zoom;
    background: #0f0f0f;
    width: n.width * zoom;
    height: l.preferred-height;
    border-radius: 3px * zoom;

    TouchArea {
        moved => {
            if (self.pressed) {
                n.x += (self.mouse-x - self.pressed-x) / zoom;
                n.y += (self.mouse-y - self.pressed-y) / zoom;
                nodes[node_idx] = n;
            }
        }
        pointer-event(event) => {
            if event.kind == PointerEventKind.up {
                NodeLogic.move_node(
                    node_idx,
                    n.x + (self.mouse-x - self.pressed-x) / zoom,
                    n.y + (self.mouse-y - self.pressed-y) / zoom,
                );
            } 
        }

        mouse-cursor: move;
    }

    l := VerticalLayout {
        padding-top: 10px * zoom;
        padding-bottom: 5px * zoom;
        HorizontalLayout {
            VerticalLayout {
                spacing: 5px * zoom;
                for input[input_idx] in n.inputs: HorizontalLayout {
                    spacing: 2px * zoom;
                    Rectangle {
                        // x: n.x - 10px;
                        width: 10px * zoom;
                        height: 10px * zoom;
                        border-bottom-right-radius: 5px * zoom;
                        border-top-right-radius: 5px * zoom;
                        background: input_ta.has-hover ? LinkLayout.colorFromstring(input.ty) : LinkLayout.colorFromstring(input.ty).darker(1);

                        input_ta := TouchArea {
                            clicked => {
                                if floating.floating_state == FloatingState.none {
                                    LinkLogic.new_link_from_input(node_idx, input_idx);
                                } else {
                                    LinkLogic.attach_link_to_input(node_idx, input_idx);
                                }
                            }
                        }
                    }
                    Text {
                        color: white;
                        height: 10px * zoom;
                        text: input.name;
                        horizontal-alignment: TextHorizontalAlignment.left;
                        font-size: 6pt * zoom;
                    }
                }
            }
            VerticalLayout {
                spacing: 5px * zoom;
                for output[output_idx] in n.outputs: HorizontalLayout {
                    spacing: 2px * zoom;
                    Text {
                        color: white;
                        height: 10px * zoom;
                        text: output.name;
                        horizontal-alignment: TextHorizontalAlignment.right;
                        font-size: 6pt * zoom;
                    }
                    Rectangle {
                        // x: n.x + n.width;
                        width: 10px * zoom;
                        height: 10px * zoom;
                        border-bottom-left-radius: 5px * zoom;
                        border-top-left-radius: 5px * zoom;
                        background: output_ta.has-hover ? LinkLayout.colorFromstring(output.ty) : LinkLayout.colorFromstring(output.ty).darker(1);
                        output_ta := TouchArea {
                            clicked => {
                                if floating.floating_state == FloatingState.none {
                                    LinkLogic.new_link_from_output(node_idx, output_idx);
                                } else {
                                    LinkLogic.attach_link_to_output(node_idx, output_idx);
                                }
                            }
                        }
                    }
                }
            }
        }

        for input[input_idx] in n.input_fields: HorizontalLayout {
            if input.ty == FieldType.select: StandardListView {
                width: 100%;
                height: 100px;
                model: input.options;
                current-item: input.default_option;

                current-item-changed(idx) => {
                    NodeLogic.set_field(node_idx, input.name, input.ty, self.model[idx].text);
                }
            }

            if input.ty == FieldType.string-input: TextEdit {
                width: 100%;
                height: 150px;
                font-size: 14px;

                text: input.default_text;

                edited(text) => {
                    NodeLogic.set_field(node_idx, input.name, input.ty, text);
                }
            }

            if input.ty == FieldType.int-input: IntInput {
                text: input.name;
                default-value: input.default_value;

                edited(text) => {
                    NodeLogic.set_field(node_idx, input.name, input.ty, text);
                }
            }

            if input.ty == FieldType.float-input: IntInput {
                text: input.name;
                default-value: input.default-value;
                input-type: InputType.decimal;

                edited(text) => {
                    NodeLogic.set_field(node_idx, input.name, input.ty, text);
                }
            }

            if input.ty == FieldType.image-output: Image {
                source: input.image;
            }
        }

        Rectangle {
            Text {
                color: white;
                text: n.text;
                wrap: TextWrap.word-wrap;
                font-size: 14pt * zoom;
            }
            padding: 15px * zoom;
        }
    }
}
