import { StandardListView, TextEdit, LineEdit } from "std-widgets.slint";
import "../../assets/AktivGrotesk-Regular.ttf";

import { LinkData, NodeData, FloatingLinkData, FloatingState, FieldType, NodeLogic, Slot } from "state.slint";
import { LinkLayout, LinkLogic } from "links.slint";
import { NodeInput } from "inputs.slint";

component NodeHeader inherits HorizontalLayout {
    in property<string> text;
    in property<float> zoom;

    alignment: LayoutAlignment.space-between;
    padding-left: 12px * zoom;
    padding-right: 12px * zoom;
    padding-bottom: 20px * zoom;
    padding-top: 4px * zoom;

    Rectangle {
        Text {
            color: #fff;
            text: text;
            wrap: TextWrap.word-wrap;
            font-size: 14px * zoom;
            font-family: "Aktiv Grotesk";
            font-weight: 500;
        }
    }

    Rectangle {
        width: 14px * zoom;
        height: 14px * zoom;

        Image {
            source: @image-url("../../assets/three-dots.svg");
            colorize: #d9d9d9;
            width <=> parent.width;
            height <=> parent.height;
        }

        TouchArea {
            mouse-cursor: MouseCursor.pointer;
        }
    }
}

component ConnectionEdge inherits HorizontalLayout {
    in property<float> zoom;
    in property<int> input-idx;
    in property<Slot> input;
    in property<FloatingLinkData> floating;
    in property<int> node-idx;
    in property<bool> left;

    spacing: 5px * zoom;
    padding-left: 12px * zoom;
    padding-right: 12px * zoom;

    function click-input() {
        if floating.floating_state == FloatingState.none {
            LinkLogic.new_link_from_input(node_idx, input_idx);
        } else {
            LinkLogic.attach_link_to_input(node_idx, input_idx);
        }
    }

    function click-output() {
        if floating.floating_state == FloatingState.none {
            LinkLogic.new_link_from_output(node_idx, input_idx);
        } else {
            LinkLogic.attach_link_to_output(node_idx, input_idx);
        }
    }

    if !left : Text {
        color: white;
        font-size: 11px * zoom;
        text: input.name;
        horizontal-alignment: TextHorizontalAlignment.right;
        vertical-alignment: TextVerticalAlignment.center;
        font-family: "Aktiv Grotesk";
        font-weight: 400;
    }
    

    Rectangle {
        clip: true;

        input_ta := TouchArea {
            clicked => {
                if left {
                    click-input();
                } else {
                    click-output();
                }
            }
        }

        VerticalLayout{
            alignment: LayoutAlignment.center;
            Image {
                source: left ? @image-url("../../assets/left-chevron.svg") : @image-url("../../assets/right-chevron.svg");
                colorize: input_ta.has-hover ? LinkLayout.colorFromstring(input.ty).brighter(1) : LinkLayout.colorFromstring(input.ty);
                width: 11px * zoom;
                height: 8px * zoom;
            }
        }
    }
    
    if left : Text {
        color: white;
        font-size: 11px * zoom;
        text: input.name;
        horizontal-alignment: TextHorizontalAlignment.left;
        font-family: "Aktiv Grotesk";
        font-weight: 400;
    }
}

export component Node inherits Rectangle {
    in-out property <NodeData> n;
    in property <int> node_idx;
    in-out property <[NodeData]> nodes;
    in property <FloatingLinkData> floating;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    x: (n.x + offset-x*1px) * zoom;
    y: (n.y - 10px + offset-y*1px) * zoom;
    background: #27282a;
    width: n.width * zoom;
    height: l.preferred-height;
    border-radius: 14px * zoom;
    border-color: #313235;
    border-width: 1px * zoom;
    clip: true;

    TouchArea {
        moved => {
            if (self.pressed) {
                n.x += (self.mouse-x - self.pressed-x) / zoom;
                n.y += (self.mouse-y - self.pressed-y) / zoom;
                nodes[node_idx] = n;
            }
        }
        pointer-event(event) => {
            if event.kind == PointerEventKind.up {
                NodeLogic.move_node(
                    node_idx,
                    n.x + (self.mouse-x - self.pressed-x) / zoom,
                    n.y + (self.mouse-y - self.pressed-y) / zoom,
                );

                // Refocus command palette
                NodeLogic.focus_callback();
            } 
        }

        mouse-cursor: move;
    }

    l := VerticalLayout {
        padding-top: 10px * zoom;
        padding-bottom: 5px * zoom;

        NodeHeader {
            zoom: zoom;
            text: n.text;
        }

        HorizontalLayout {
            padding-bottom: 8px * zoom;

            VerticalLayout {
                spacing: 5px * zoom;
                for input[input_idx] in n.inputs: ConnectionEdge {
                    zoom: zoom;
                    input_idx: input_idx;
                    input: input;
                    floating: floating;
                    node_idx: node_idx;
                    left: true;
                }
            }
            VerticalLayout {
                spacing: 5px * zoom;
                alignment: LayoutAlignment.start;
                for output[output_idx] in n.outputs: ConnectionEdge {
                    zoom: zoom;
                    input_idx: output_idx;
                    input: output;
                    floating: floating;
                    node_idx: node_idx;
                    left: false;
                }
            }
        }

        for input[input_idx] in n.input_fields: NodeInput {
            node_idx: node_idx;
            field_meta: input;
            zoom: zoom;
            padding-left: 12px * zoom;
            padding-right: 12px * zoom;
            padding-top: 4px * zoom;
        }
    }
}
