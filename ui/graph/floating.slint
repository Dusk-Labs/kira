import { FloatingState, FloatingLinkData, NodeData } from "state.slint";
import { LinkLayout } from "links.slint";

export component MoveArea inherits TouchArea {
    in-out property <FloatingLinkData> floating;
    pointer-event(evt) => {
        self.enabled = false;
        MoveAreaLogic.mouse_event_tap_hack(
            self.absolute-position.x + self.x + self.mouse-x,
            self.absolute-position.y + self.y + self.mouse-y,
            self.x + self.mouse-x,
            self.y + self.mouse-y,
            evt
        );
        self.enabled = true;
    }
}

export global MoveAreaLogic {
    callback mouse_event_tap_hack(length, length, length, length, PointerEvent);
    callback reset_floating_state();
}

export component Floating inherits Rectangle {
    in property <FloatingLinkData> floating;
    in property <[NodeData]> nodes;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    Path {
        stroke: LinkLayout.colorFromstring(floating.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo {
            x: floating.floating_state == FloatingState.src_attached
                ? (LinkLayout.srcX(nodes[floating.node])+5 + offset-x) * zoom
                : (LinkLayout.dstX(nodes[floating.node])+5 + offset-x) * zoom;
            y: floating.floating_state == FloatingState.src_attached
                ? (LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5 + offset-y) * zoom
                : (LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5 + offset-y) * zoom;
        }
        CubicTo { 
            control-1-x: floating.floating_state == FloatingState.src_attached
                ? (LinkLayout.srcX(nodes[floating.node])+5 + 100 + offset-x) * zoom
                : (LinkLayout.dstX(nodes[floating.node])+5 - 100 + offset-x) * zoom;
            control-1-y: floating.floating_state == FloatingState.src_attached
                ? (LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5 + offset-y) * zoom
                : (LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5 + offset-y) * zoom;
            control-2-x: floating.x/1px;
            control-2-y: floating.y/1px; 
            x: floating.x/1px;
            y: floating.y/1px; 
        }
    }
}

export component FloatingSlots inherits Rectangle {
    in property <FloatingLinkData> floating;
    in property <[NodeData]> nodes;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    in property <float> zoom;
    in property <float> offset-x;
    in property <float> offset-y;

    pure function is-right-facing() -> bool {
        return floating.floating_state == FloatingState.src_attached;
    }

    function image() -> image {
        if is-right-facing() {
            return @image-url("../../assets/right-chevron.svg");
        } else {
            return @image-url("../../assets/left-chevron.svg");
        }
    }

    Rectangle {
        x: floating.floating_state == FloatingState.src_attached
            ? (LinkLayout.srcX(nodes[floating.node]) + offset-x)*1px * zoom
            : (LinkLayout.dstX(nodes[floating.node]) + offset-x)*1px * zoom;

        y: floating.floating_state == FloatingState.src_attached
            ? (LinkLayout.srcY(nodes[floating.node], floating.node_slot) + offset-y)*1px * zoom
            : (LinkLayout.dstY(nodes[floating.node], floating.node_slot) + offset-y)*1px * zoom;

        width: 11px * zoom;
        height: 8px * zoom;

        VerticalLayout {
            alignment: LayoutAlignment.center;

            Image {
                source: root.image();
                colorize: LinkLayout.colorFromstring(floating.ty);
                width: 11px * zoom;
                height: 8px * zoom;
            }
        }
    }
}
