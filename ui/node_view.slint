export struct LinkData {
    src: int,
    src_slot: int,
    dst: int,
    dst_slot: int,
    ty: string,
}

export enum FloatingState {
    src_attached,
    dst_attached,
    none,
}

export struct FloatingLinkData {
    floating_state: FloatingState,
    node: int,
    node_slot: int,
    ty: string,
    x: length,
    y: length,
}

export struct Slot {
    name: string,
    ty: string,
}

export struct Node { 
    x: length,
    y: length,
    width: length,
    text: string,
    inputs: [Slot],
    outputs: [Slot],
}

component MoveArea inherits TouchArea {
    in-out property <FloatingLinkData> floating;
    pointer-event(evt) => {
        self.enabled = false;
        MoveAreaLogic.mouse_event_tap_hack(
            self.absolute-position.x + self.x + self.mouse-x,
            self.absolute-position.y + self.y + self.mouse-y,
            self.x + self.mouse-x,
            self.y + self.mouse-y,
            evt
        );
        self.enabled = true;
    }
}

export global MoveAreaLogic {
    callback mouse_event_tap_hack(length, length, length, length, PointerEvent);
    callback reset_floating_state();
}

export global LinkLogic {
    callback new_link_from_output(int, int);
    callback attach_link_to_output(int, int);
    callback new_link_from_input(int, int);
    callback attach_link_to_input(int, int);
}

export global NodeLogic {
    callback move_node(int, length, length);
}


global LinkLayout {
    pure public function colorFromstring(ty: string) -> color {
        if ty == "TXT" {
            orange
        } else if ty == "IMG"{
            lightblue
        } else {
            red
        }
    }
    pure public function srcX(src: Node) -> float {
        return (src.x + src.width - 10px) / 1px;
    }
    pure public function srcY(src: Node, src_slot: int) -> float {
        return src.y / 1px + 15 * src_slot;
    }
    pure public function dstX(dst: Node) -> float {
        return dst.x / 1px;
    }
    pure public function dstY(dst: Node, dst_slot: int) -> float {
        return dst.y / 1px + 15 * dst_slot;
    }
    
}

component Floating inherits Rectangle {
    in property <FloatingLinkData> floating;
    in property <[Node]> nodes;
    in property <float> mouse-x;
    in property <float> mouse-y;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    Path {
        stroke: LinkLayout.colorFromstring(floating.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo {
            x: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcX(nodes[floating.node])+5
                : LinkLayout.dstX(nodes[floating.node])+5;
            y: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5
                : LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5;
        }
        CubicTo { 
            control-1-x: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcX(nodes[floating.node])+5 + 100
                : LinkLayout.dstX(nodes[floating.node])+5 - 100;
            control-1-y: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5
                : LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5;
            control-2-x: floating.x/1px;
            control-2-y: floating.y/1px; 
            x: floating.x/1px;
            y: floating.y/1px; 
        }
    }
}

component Link inherits Rectangle {
    in property <LinkData> link;
    in property <[Node]> nodes;
    in property <float> viewbox-height;
    in property <float> viewbox-width;


    Path {
        stroke: LinkLayout.colorFromstring(link.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo { x: LinkLayout.srcX(nodes[link.src])+5; y: LinkLayout.srcY(nodes[link.src], link.src_slot)+5; }
        CubicTo { 
            control-1-x: LinkLayout.srcX(nodes[link.src])+5 + 100;
            control-1-y: LinkLayout.srcY(nodes[link.src], link.src_slot)+5; 

            control-2-x: LinkLayout.dstX(nodes[link.dst])+5 - 100;
            control-2-y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5; 
            x: LinkLayout.dstX(nodes[link.dst])+5;
            y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5; 
        }
    }
}

component LinkSlots inherits Rectangle{
    in property <LinkData> link;
    in property <[Node]> nodes;
    Rectangle {
        x: LinkLayout.srcX(nodes[link.src])*1px;
        y: LinkLayout.srcY(nodes[link.src], link.src_slot)*1px;
        width: 10px;
        height: 10px;
        border-bottom-left-radius: 5px;
        border-top-left-radius: 5px;
        background: LinkLayout.colorFromstring(link.ty);
    }
    Rectangle {
        x: LinkLayout.dstX(nodes[link.dst])*1px;
        y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)*1px;
        width: 10px;
        height: 10px;
        border-bottom-right-radius: 5px;
        border-top-right-radius: 5px;
        background: LinkLayout.colorFromstring(link.ty);
    }
    
}

component FloatingSlots inherits Rectangle {
    in property <FloatingLinkData> floating;
    in property <[Node]> nodes;
    in property <float> mouse-x;
    in property <float> mouse-y;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    Rectangle {
        x: floating.floating_state == FloatingState.src_attached
            ? LinkLayout.srcX(nodes[floating.node])*1px
            : LinkLayout.dstX(nodes[floating.node])*1px;
        y: floating.floating_state == FloatingState.src_attached
            ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)*1px
            : LinkLayout.dstY(nodes[floating.node], floating.node_slot)*1px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        border-bottom-left-radius: floating.floating_state == FloatingState.src_attached ? 5px : 0px;
        border-top-left-radius: floating.floating_state == FloatingState.src_attached ? 5px : 0px;
        border-bottom-right-radius: floating.floating_state == FloatingState.src_attached ? 0px : 5px;
        border-top-right-radius: floating.floating_state == FloatingState.src_attached ? 0px : 5px;
        background: LinkLayout.colorFromstring(floating.ty);
    }
    // Rectangle {
    //     x: floating.x - 5px;
    //     y: floating.y - 5px;
    //     width: 10px;
    //     height: 10px;
    //     border-bottom-left-radius: floating.floating_state == FloatingState.src_attached ? 0px : 5px;
    //     border-top-left-radius: floating.floating_state == FloatingState.src_attached ? 0px : 5px;
    //     border-bottom-right-radius: floating.floating_state == FloatingState.src_attached ? 5px : 0px;
    //     border-top-right-radius: floating.floating_state == FloatingState.src_attached ? 5px : 0px;
    //     background: LinkLayout.colorFromstring(floating.ty);
    // }
}

export component Graph inherits Rectangle {
    background: #1f1f1f;
    preferred-height: 100%;
    preferred-width: 100%;
    in-out property <[Node]> nodes;
    in property <[LinkData]> links;
    in-out property <FloatingLinkData> floating;

    // catch mouse events in the background
     TouchArea {
        clicked => {
            if floating.floating_state != FloatingState.none {
                 MoveAreaLogic.reset_floating_state();
            }
        }
    }

    if floating.floating_state != FloatingState.none: Floating {
        floating: floating;
        nodes: nodes;
        viewbox-height: self.height /1px;
        viewbox-width: self.width /1px;
    }

    for l[idx] in links : Link {
        link: l;
        nodes: nodes;
        viewbox-height: self.height /1px;
        viewbox-width: self.width /1px;
    }

    for n[node_idx] in nodes : r:= Rectangle {
        x: n.x;
        y: n.y - 10px;
        background: #0f0f0f;
        width: n.width;
        height: l.preferred-height;
        border-radius: 3px;
        TouchArea {
            moved => {
                if (self.pressed) {
                    n.x += self.mouse-x - self.pressed-x;
                    n.y += self.mouse-y - self.pressed-y;
                    nodes[node_idx] = n;
                }
            }
            pointer-event(event) => {
                if event.kind == PointerEventKind.up {
                    NodeLogic.move_node(
                        node_idx,
                        n.x + self.mouse-x - self.pressed-x,
                        n.y + self.mouse-y - self.pressed-y,
                    );
                } 
            }

            mouse-cursor: move;
        }

        l := VerticalLayout {
            padding-top: 10px;
            padding-bottom: 5px;
            HorizontalLayout {
                VerticalLayout {
                    spacing: 5px;
                    for input[input_idx] in n.inputs: HorizontalLayout {
                        spacing: 2px;
                        Rectangle {
                            // x: n.x - 10px;
                            width: 10px;
                            height: 10px;
                            border-bottom-right-radius: 5px;
                            border-top-right-radius: 5px;
                            background: input_ta.has-hover ? LinkLayout.colorFromstring(input.ty) : LinkLayout.colorFromstring(input.ty).darker(1);
                            input_ta := TouchArea {
                                clicked => {
                                    if floating.floating_state == FloatingState.none {
                                        LinkLogic.new_link_from_input(node_idx, input_idx);
                                    } else {
                                        LinkLogic.attach_link_to_input(node_idx, input_idx);
                                    }
                                }
                            }
                        }
                        Text {
                            color: white;
                            height: 10px;
                            text: input.name;
                            horizontal-alignment: TextHorizontalAlignment.left;
                            font-size: 6px;
                        }
                    }
                }
                VerticalLayout {
                    spacing: 5px;
                    for output[output_idx] in n.outputs: HorizontalLayout {
                        spacing: 2px;
                        Text {
                            color: white;
                            height: 10px;
                            text: output.name;
                            horizontal-alignment: TextHorizontalAlignment.right;
                            font-size: 6px;
                        }
                        Rectangle {
                            // x: n.x + n.width;
                            width: 10px;
                            height: 10px;
                            border-bottom-left-radius: 5px;
                            border-top-left-radius: 5px;
                            background: output_ta.has-hover ? LinkLayout.colorFromstring(output.ty) : LinkLayout.colorFromstring(output.ty).darker(1);
                            output_ta := TouchArea {
                                clicked => {
                                    if floating.floating_state == FloatingState.none {
                                        LinkLogic.new_link_from_output(node_idx, output_idx);
                                    } else {
                                        LinkLogic.attach_link_to_output(node_idx, output_idx);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Rectangle {
                Text {
                    color: white;
                    text: n.text;
                    wrap: TextWrap.word-wrap;
                }
                padding: 15px;
            }
        }
    }

    if floating.floating_state != FloatingState.none: FloatingSlots {
        floating: floating;
        nodes: nodes;
        viewbox-height: self.height /1px;
        viewbox-width: self.width /1px;
    }

    for l[idx] in links : LinkSlots {
        link: l;
        nodes: nodes;
    }

    if floating.floating_state != FloatingState.none: MoveArea {
        floating: floating;
    }
}
