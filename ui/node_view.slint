export struct LinkData {
    src: int,
    src_slot: int,
    dst: int,
    dst_slot: int,
    ty: string,
}

export enum FloatingState {
    src_attached,
    dst_attached,
    none,
}

export struct FloatingLinkData {
    floating_state: FloatingState,
    node: int,
    node_slot: int,
    ty: string,
    x: length,
    y: length,
}

export struct Node { 
    x: length,
    y: length,
    width: length,
    text: string,
    inputs: [string],
    outputs: [string],
}

component MoveArea inherits TouchArea {
    in-out property <FloatingLinkData> floating;
    pointer-event(evt) => {
        if evt.kind == PointerEventKind.down {
            self.enabled = false;
            MoveAreaLogic.click_event_hack(self.mouse-x, self.mouse-y, evt);
            self.enabled = true;
        } else if evt.kind == PointerEventKind.move {
            MoveAreaLogic.update_floating_position(
                self.x + self.mouse-x,
                self.y + self.mouse-y,
            );
        }
    }
}

export global MoveAreaLogic {
    callback click_event_hack(length, length, PointerEvent);
    callback update_floating_position(length, length);
    callback reset_floating_state();
}

export global LinkLogic {
    callback new_link_from_output(int, int);
    callback attach_link_to_output(int, int);
    callback new_link_from_input(int, int);
    callback attach_link_to_input(int, int);
}

export global NodeLogic {
    callback move_node(int, length, length);
}


global LinkLayout {
    pure public function colorFromstring(ty: string) -> color {
        if ty == "TXT" {
            orange
        } else if ty == "IMG"{
            lightblue
        } else {
            red
        }
    }
    pure public function srcX(src: Node) -> float {
        return (src.x + src.width) / 1px;
    }
    pure public function srcY(src: Node, src_slot: int) -> float {
        return src.y / 1px + 15 * src_slot;
    }
    pure public function dstX(dst: Node) -> float {
        return dst.x / 1px - 10;
    }
    pure public function dstY(dst: Node, dst_slot: int) -> float {
        return dst.y / 1px + 15 * dst_slot;
    }
    
}

component Floating inherits Rectangle {
    in property <FloatingLinkData> floating;
    in property <[Node]> nodes;
    in property <float> mouse-x;
    in property <float> mouse-y;
    in property <float> viewbox-height;
    in property <float> viewbox-width;
    Rectangle {
        x: floating.floating_state == FloatingState.src_attached
            ? LinkLayout.srcX(nodes[floating.node])*1px
            : LinkLayout.dstX(nodes[floating.node])*1px;
        y: floating.floating_state == FloatingState.src_attached
            ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)*1px
            : LinkLayout.dstY(nodes[floating.node], floating.node_slot)*1px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background: LinkLayout.colorFromstring(floating.ty);
    }
    Rectangle {
        x: floating.x - 5px;
        y: floating.y - 5px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background: LinkLayout.colorFromstring(floating.ty);
    }
    Path {
        stroke: LinkLayout.colorFromstring(floating.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo {
            x: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcX(nodes[floating.node])+5
                : LinkLayout.dstX(nodes[floating.node])+5;
            y: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5
                : LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5;
        }
        CubicTo { 
            control-1-x: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcX(nodes[floating.node])+5 + 100
                : LinkLayout.dstX(nodes[floating.node])+5 - 100;
            control-1-y: floating.floating_state == FloatingState.src_attached
                ? LinkLayout.srcY(nodes[floating.node], floating.node_slot)+5
                : LinkLayout.dstY(nodes[floating.node], floating.node_slot)+5;
            control-2-x: floating.x/1px;
            control-2-y: floating.y/1px; 
            x: floating.x/1px;
            y: floating.y/1px; 
        }
    }
}

component Link inherits Rectangle {
    in property <LinkData> link;
    in property <[Node]> nodes;
    in property <float> viewbox-height;
    in property <float> viewbox-width;


    Path {
        stroke: LinkLayout.colorFromstring(link.ty);
        viewbox-height: viewbox-height;
        viewbox-width: viewbox-width;
        stroke-width: 3px;

        MoveTo { x: LinkLayout.srcX(nodes[link.src])+5; y: LinkLayout.srcY(nodes[link.src], link.src_slot)+5; }
        CubicTo { 
            control-1-x: LinkLayout.srcX(nodes[link.src])+5 + 100;
            control-1-y: LinkLayout.srcY(nodes[link.src], link.src_slot)+5; 

            control-2-x: LinkLayout.dstX(nodes[link.dst])+5 - 100;
            control-2-y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5; 
            x: LinkLayout.dstX(nodes[link.dst])+5;
            y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)+5; 
        }
    }
    Rectangle {
        x: LinkLayout.srcX(nodes[link.src])*1px;
        y: LinkLayout.srcY(nodes[link.src], link.src_slot)*1px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background: LinkLayout.colorFromstring(link.ty);
    }
    Rectangle {
        x: LinkLayout.dstX(nodes[link.dst])*1px;
        y: LinkLayout.dstY(nodes[link.dst], link.dst_slot)*1px;
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background: LinkLayout.colorFromstring(link.ty);
    }
}

export component Graph inherits Rectangle {
    background: #1f1f1f;
    preferred-height: 100%;
    preferred-width: 100%;
    in-out property <[Node]> nodes;
    in property <[LinkData]> links;
    in-out property <FloatingLinkData> floating;

    // catch mouse events in the background
     TouchArea {
        clicked => {
            if floating.floating_state != FloatingState.none {
                 MoveAreaLogic.reset_floating_state();
            }
        }
    }

    if floating.floating_state != FloatingState.none: Floating {
        floating: floating;
        nodes: nodes;
        viewbox-height: self.height /1px;
        viewbox-width: self.width /1px;
    }

    for l[idx] in links : Link {
        link: l;
        nodes: nodes;
        viewbox-height: self.height /1px;
        viewbox-width: self.width /1px;
    }

    for n[node_idx] in nodes: VerticalLayout {
        y: n.y;
        spacing: 5px;
        for input[input_idx] in n.inputs: Rectangle {
            x: n.x - 10px;
            width: 10px;
            height: 10px;
            border-color: input_ta.has-hover ? LinkLayout.colorFromstring(input).darker(1) : LinkLayout.colorFromstring(input);
            border-radius: 5px;
            border-width: 2px;
            background: input_ta.has-hover ? LinkLayout.colorFromstring(input).darker(1) : transparent;
            input_ta := TouchArea {
                clicked => {
                    if floating.floating_state == FloatingState.none {
                        LinkLogic.new_link_from_input(node_idx, input_idx);
                    } else {
                        LinkLogic.attach_link_to_input(node_idx, input_idx);
                    }
                }
            }
        }
    }

    for n[node_idx] in nodes: VerticalLayout {
        y: n.y;
        spacing: 5px;
        for output[output_idx] in n.outputs: Rectangle {
            x: n.x + n.width;
            width: 10px;
            height: 10px;
            border-color: output_ta.has-hover ? LinkLayout.colorFromstring(output).darker(1) : LinkLayout.colorFromstring(output);
            border-radius: 5px;
            border-width: 2px;
            background: output_ta.has-hover ? LinkLayout.colorFromstring(output).darker(1) : transparent;
            output_ta := TouchArea {
                clicked => {
                    if floating.floating_state == FloatingState.none {
                        LinkLogic.new_link_from_output(node_idx, output_idx);
                    } else {
                        LinkLogic.attach_link_to_output(node_idx, output_idx);
                    }
                }
            }
        }
    }


    for n[idx] in nodes : r:= Rectangle {
        x: n.x;
        y: n.y;
        background: gray;
        width: n.width;
        height: l.preferred-height;
        border-radius: 3px;

        l := HorizontalLayout {
            Text { text: n.text; wrap: TextWrap.word-wrap; }
            padding: 15px;
        }

        TouchArea {
            moved => {
                if (self.pressed) {
                    n.x += self.mouse-x - self.pressed-x;
                    n.y += self.mouse-y - self.pressed-y;
                    nodes[idx] = n;
                    NodeLogic.move_node(
                        idx,
                        n.x + self.mouse-x - self.pressed-x,
                        n.y + self.mouse-y - self.pressed-y,
                    );
                }
            }
            mouse-cursor: move;
        }
    }
    if floating.floating_state != FloatingState.none: MoveArea {
        floating: floating;
    }
}
